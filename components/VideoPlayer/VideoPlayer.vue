<template>
  <div class="video-player-wrapper">
    <div
      v-if="settingStates.switchBackgroud"
      class="overlay-backdrop"
    >
      <!-- <canvas ref="canvasOverlayBackdrop"> </canvas> -->
      <NuxtImg
        :src="backdrop"
        format="avif"
        loading="lazy"
        alt=""
      />
    </div>

    <div
      ref="videoPlayer"
      class="video-player"
      :class="{
        scrubbing: videoStates.isScrubbingProgressBar,
        'hide-controls': videoStates.isHideControls,
        'show-controls': videoStates.isShowControls,
        pause: !videoStates.isPlayVideo || videoStates.isEndedVideo,
        'full-screen': videoStates.isFullScreen,
        settings: settingStates.enable
      }"
      @click="handleClickVideoPlayer"
    >
      <div class="ratio-16-9"></div>
      <div
        class="box-video"
        v-show="!loadingData"
      >
        <!-- :src="videoSrc" -->
        <video
          v-if="isEligibleToWatch"
          id="video-player"
          ref="video"
          :poster="backdrop"
          @loadstart="onLoadStartVideo"
          @loadeddata="onLoadedDataVideo"
          @canplay="onCanPlayVideo"
          @timeupdate="onTimeUpdateVideo"
          @ended="onEndedVideo"
          @waiting="onWaitingVideo"
          @progress="onProgressVideo"
          @play="onPlayVideo"
          @pause="onPauseVideo"
          @playing="onPLayingVideo"
          :playsinline="true"
        >
          <!-- <source src="blobVideoSrc" ref="srcVideo" type="video/mp4" /> -->
        </video>

        <div
          v-else
          class="require-vip"
        >
          <!-- <div class="ratio-16-9"></div> -->
          <div
            v-if="ísWatchable"
            class="require-vip-wrapper"
          >
            <div
              v-if="authStore.vipNumber == 0"
              class="require-vip-message"
            >
              <span>
                Bạn cần nâng cấp tài khoản lên
                <strong>VIP {{ movieVipNumber }}</strong> để tiếp tục xem phim.
              </span>
              <NuxtLink
                class="underline"
                :to="{
                  path: `/upgrade/plans`,
                  query: {
                    order: movieVipNumber
                  }
                }"
              >
                Nâng cấp ngay
              </NuxtLink>
            </div>
            <div
              v-else
              class="require-vip-message"
            >
              <span>
                Bạn cần nâng cấp tài khoản lên
                <strong>VIP {{ movieVipNumber }}</strong> để tiếp tục xem phim
              </span>
              <NuxtLink
                class="underline"
                :to="{
                  path: `/upgrade/plans`,
                  query: {
                    order: movieVipNumber
                  }
                }"
              >
                Nâng cấp ngay
              </NuxtLink>
            </div>
          </div>
        </div>
      </div>

      <div class="float-center">
        <div
          v-show="
            (videoStates.isLoading &&
              !videoStates.isEndedVideo &&
              !videoStates.isRewind.enable) ||
            !mounted ||
            loadingData
          "
          class="loading-video"
        >
          <LoadingSpinner />
        </div>

        <div
          v-if="isEligibleToWatch"
          v-show="videoStates.isEndedVideo"
          class="replay"
        >
          <!-- <Icon
            name="ic:baseline-replay"
            class="replay"
            @click="onClickReplayVideo"
          /> -->
          <ReplayIcon
            width="4rem"
            height="4rem"
            fill="currentColor"
            @click="onClickReplayVideo"
          />

          <span @click="onClickReplayVideo"> Phát lại </span>
        </div>

        <div
          v-if="isEligibleToWatch"
          v-show="
            videoStates.isShowNotify && isInHistory && !videoStates.isLoading
          "
          class="notify-keep-watching"
        >
          <CloseBtn
            class="transparent close-notify"
            @click="videoStates.isShowNotify = false"
          />

          <div class="notify-played">
            <span>
              Bạn đã xem đến:
              {{ formatDuration(historyProgress.seconds) }}
            </span>
          </div>

          <div class="notify-actions">
            <a-button
              class="click-active"
              type="text"
              @click="onClickPlayAgain"
            >
              Xem lại từ đầu
            </a-button>
            <a-button
              v-show="video!?.duration - historyProgress.seconds > 10"
              class="click-active"
              type="text"
              @click="onClickKeepWatching"
            >
              Xem tiếp
            </a-button>
          </div>
        </div>
      </div>

      <div
        v-if="isEligibleToWatch"
        class="overlay-controls-animation"
        :class="{
          active: videoStates.isActiveControlsAnimation,
          rewind: videoStates.isRewind.enable
        }"
      >
        <div class="box-icon">
          <div
            v-show="!videoStates.isRewind.enable"
            class="play-pause"
          >
            <PlayIcon
              v-show="!videoStates.isPlayVideo && !videoStates.isEndedVideo"
              class="play"
              width="3rem"
              height="3rem"
              fill="currentColor"
              @click="onClickVideo"
            />

            <PauseIcon
              v-show="videoStates.isPlayVideo && !videoStates.isEndedVideo"
              class="play"
              width="3rem"
              height="3rem"
              fill="currentColor"
              @click="onClickVideo"
            />
          </div>

          <div
            v-show="videoStates.isRewind.enable"
            class="rewind-forward"
          >
            <span v-show="videoStates.isRewind.replay">-10</span>
            <span v-show="videoStates.isRewind.forward">+10</span>
          </div>
        </div>
      </div>

      <div
        v-if="isEligibleToWatch"
        ref="timeline"
        class="timeline"
        :class="{
          active:
            videoStates.isMouseMoveOverlayProgress ||
            videoStates.isScrubbingProgressBar
        }"
      >
        <div class="timeline-container">
          <div class="img-box ratio-16-9">
            <canvas
              ref="canvasPreviewImg"
              class="canvas-preview-img"
            >
            </canvas>
            <!-- <NuxtImg class="preview-img" format="avif" loading="lazy" alt="" /> -->
          </div>
        </div>
        <span class="timeline-indicator">{{ timelineUpdate }} </span>
      </div>

      <!-- v-show="videoStates.isLoaded || mounted" -->
      <div
        v-if="isEligibleToWatch"
        class="controls"
        :class="{
          scrubbing: videoStates.isScrubbingProgressBar
        }"
        tabindex="-1"
        @keydown="onKeyDownVideo"
      >
        <div class="controls-container">
          <div
            ref="overlayProgress"
            class="overlay-progress"
            @pointermove="onMouseMoveProgressBar"
            @touchmove="onTouchMoveProgressBar"
            @pointerdown="onMouseDownProgressBar"
            @touchstart="onTouchStartProgressBar"
            @pointerup="onMouseUpProgressBar"
            @touchend="onTouchEndProgressBar"
            @pointerleave="onMouseLeaveProgressBar"
          >
            <div class="overlay-progress-padding"></div>

            <div class="preview-progress"></div>

            <div class="seekable-progress"></div>

            <div
              ref="progressBar"
              class="progress-bar"
            >
              <div class="scrubber-point"></div>
            </div>
          </div>

          <div class="main-controls">
            <div class="left">
              <div class="play-pause">
                <ReplayIcon
                  v-show="videoStates.isEndedVideo"
                  class="replay"
                  width="2.6rem"
                  height="2.6rem"
                  fill="currentColor"
                  @click="onClickReplayVideo"
                />

                <PlayIcon
                  v-show="!videoStates.isPlayVideo && !videoStates.isEndedVideo"
                  class="play"
                  width="2.6rem"
                  height="2.6rem"
                  fill="currentColor"
                  @click="onClickPlay"
                />

                <PauseIcon
                  v-show="videoStates.isPlayVideo && !videoStates.isEndedVideo"
                  class="pause"
                  width="2.6rem"
                  height="2.6rem"
                  fill="currentColor"
                  @click="onClickPause"
                />
              </div>

              <div class="rewind-forward">
                <RewindIcon
                  class="rewind"
                  width="2.6rem"
                  height="2.6rem"
                  fill="currentColor"
                  @click="onClickRewind"
                />
              </div>

              <div class="volume">
                <div>
                  <VolumeDown
                    v-show="!videoStates.isVolumeOff && volume <= 30"
                    class="volume-down"
                    width="2.7rem"
                    height="2.7rem"
                    fill="currentColor"
                    @click="onClickVolumeUp"
                  />

                  <VolumeUp
                    v-show="!videoStates.isVolumeOff && volume > 30"
                    name="ic:baseline-volume-up"
                    width="2.7rem"
                    height="2.7rem"
                    fill="currentColor"
                    @click="onClickVolumeUp"
                  />

                  <VolumeOff
                    v-show="videoStates.isVolumeOff"
                    name="ic:baseline-volume-off"
                    width="2.7rem"
                    height="2.7rem"
                    fill="currentColor"
                    @click="onClickVolumeOff"
                  />
                </div>
                <!-- <a-slider
                  class="volume-slider"
                  :class="{ muted: videoStates.isVolumeOff }"
                  v-model:value="volume"
                  :tooltip="{ open: false }"
                  @change="onChangeVolume(volume)"
                /> -->

                <el-slider
                  v-model="volume"
                  class="volume-slider"
                  :class="{
                    muted: videoStates.isVolumeOff,
                    changing: videoStates.isChangingVolume
                  }"
                  :debounce="0"
                  @input="onChangeVolume(volume)"
                  @change="onChangeVolume(volume)"
                />
              </div>

              <div class="timeupdate-duration">
                <span class="timeupdate">{{ timeUpdate }} </span>
                <span class="separate"> / </span>
                <span class="duration">{{ duration }} </span>
              </div>
            </div>

            <div class="right">
              <div class="rewind-forward">
                <FastRewind
                  width="2.7rem"
                  height="2.7rem"
                  fill="currentColor"
                  @click="onClickRewind"
                />

                <FastForward
                  width="2.7rem"
                  height="2.7rem"
                  fill="currentColor"
                  @click="onClickForward"
                />
              </div>

              <div
                class="setting"
                :class="{ active: settingStates.enable }"
              >
                <SettingIcon
                  class="setting"
                  width="2.5rem"
                  height="2.5rem"
                  fill="currentColor"
                  @click="
                    settingStates.enable = !settingStates.enable;
                    onCloseSettings();
                  "
                />
              </div>

              <div class="picture-in-picture">
                <PictureInPicture
                  width="2.7rem"
                  height="2.7rem"
                  fill="currentColor"
                  @click="onClickPictureInPicture"
                />
              </div>

              <div class="fullscreen-exit">
                <FullscreenIcon
                  v-show="!videoStates.isFullScreen"
                  class="fullscreen"
                  width="3.3rem"
                  height="3.3rem"
                  fill="currentColor"
                  @click="onClickFullScreen"
                />

                <FullscreenExitIcon
                  v-show="videoStates.isFullScreen"
                  width="3.3rem"
                  height="3.3rem"
                  fill="currentColor"
                  @click="onClickFullScreenExit"
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        v-if="isEligibleToWatch"
        class="video-mask"
        tabindex="-1"
        @click="onClickVideo"
        @pointermove="onMouseMoveVideo"
        @touchmove="onMouseMoveVideo"
        @pointerleave="onMouseLeaveVideo"
        @keydown="onKeyDownVideo"
      ></div>

      <div
        v-if="!loadingData && isEligibleToWatch"
        class="background-controls"
        :style="{
          // backgroundImage: `url(${getImage(
          //   'background-gradient-opacity.png',
          //   'background/gradient'
          // )})`
          backgroundImage: `url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAACbCAYAAACj6PGsAAAAAXNSR0IArs4c6QAAAPVJREFUOE9lyNdHBQAARvHb3nvvuu2997jNe29TJJEkkkgSSSSJJJFEEkkiSfRH5rycl76Hn+MLBP4thidW4qh4SJBEKkmSqRRJpdIkncqATMmisiWHypU8Kl8KqEIokmKqREqpMimnKqSSqoJqqaGCUkvVST3VII1UEzRLC9UqbVS7dFCd0CXdVI/0Un3STw3IIDUEwzJCjcoYNS4TVEgmqSmZpmZgVuaosESoqMxTC7AoS9QyrMAqrME6bMAmbME27MAu7ME+HMAhHMExnMApnME5XMAlXME13MAt3ME9PMAjPMEzvMArvME7fMAnfME3/MDvH+JDJTFIrPkwAAAAAElFTkSuQmCC)`
        }"
      ></div>

      <div
        v-if="isEligibleToWatch"
        class="settings"
        :class="{
          active: settingStates.enable && !videoStates.isHideControls,
          general: !settingStates.subSetting.enable,
          'sub-setting': settingStates.subSetting.enable
        }"
      >
        <div
          v-show="!settingStates.subSetting.enable"
          class="setting-options"
        >
          <div
            class="setting-item switch-background"
            @click="
              settingStates.switchBackgroud = !settingStates.switchBackgroud
            "
          >
            <div class="left">
              <!-- <Icon name="ic:outline-light-mode" /> -->

              <LightMode
                width="2rem"
                height="2rem"
                fill="currentColor"
              />
              <span>Nền sáng</span>
            </div>
            <div class="right">
              <a-switch
                v-model:checked="settingStates.switchBackgroud"
                @click="
                  settingStates.switchBackgroud = !settingStates.switchBackgroud
                "
              />
            </div>
          </div>
          <div
            class="setting-item playback"
            @click="
              settingStates.subSetting.enable = true;
              settingStates.subSetting.playback = true;
            "
          >
            <div class="left">
              <!-- <Icon name="ic:baseline-fast-forward" /> -->

              <FastForward
                width="2rem"
                height="2rem"
                fill="currentColor"
              />
              <span>Tốc độ phát</span>
            </div>

            <div class="right">
              <span>{{ settings.playback.current }}</span>
              <!-- <Icon name="ic:baseline-arrow-forward-ios" /> -->

              <ArrowForwardIos
                width="1.5rem"
                height="1.5rem"
                fill="currentColor"
              />
            </div>
          </div>

          <div
            class="setting-item quality"
            @click="
              settingStates.subSetting.enable = true;
              settingStates.subSetting.quality = true;
            "
          >
            <div class="left">
              <!-- <Icon name="ic:baseline-high-quality" /> -->

              <HighQuality
                width="2rem"
                height="2rem"
                fill="currentColor"
              />
              <span>Chất lượng</span>
            </div>

            <div class="right">
              <span>{{ settings.quality.current }}</span>
              <!-- <Icon name="ic:baseline-arrow-forward-ios" /> -->

              <ArrowForwardIos
                width="1.5rem"
                height="1.5rem"
                fill="currentColor"
              />
            </div>
          </div>
        </div>

        <div
          v-show="settingStates.subSetting.enable"
          class="sub-setting"
          :class="{
            playback: settingStates.subSetting.playback,
            quality: settingStates.subSetting.quality
          }"
        >
          <div
            v-show="settingStates.subSetting.playback"
            class="sub-setting-item play-back"
          >
            <div
              class="header"
              @click="
                settingStates.subSetting.enable = false;
                settingStates.subSetting.playback = false;
              "
            >
              <div class="left">
                <!-- <Icon name="ic:baseline-arrow-back-ios" /> -->

                <ArrowBackIos
                  width="1.4rem"
                  height="1.4rem"
                  fill="currentColor"
                />
                <span>Tốc độ phát</span>
              </div>
              <div class="right">
                <span>Tùy chỉnh</span>
              </div>
            </div>

            <ul class="menu">
              <li
                v-for="(item, index) in settings.playback.all"
                :key="index"
                :class="{ active: settings.playback.current == item }"
                @click="onClickItemPlayback(item)"
              >
                <!-- <Icon
                  v-if="settings.playback.current == item"
                  name="ic:baseline-check"
                /> -->

                <CheckIcon
                  v-if="settings.playback.current == item"
                  width="1.8rem"
                  height="1.8rem"
                  fill="currentColor"
                />
                <span> {{ item }}</span>
              </li>
            </ul>
          </div>

          <div
            v-show="settingStates.subSetting.quality"
            class="sub-setting-item quality"
          >
            <div
              class="header"
              @click="
                settingStates.subSetting.enable = false;
                settingStates.subSetting.quality = false;
              "
            >
              <div class="left">
                <!-- <Icon name="ic:baseline-arrow-back-ios" /> -->

                <ArrowBackIos
                  width="1.4rem"
                  height="1.4rem"
                  fill="currentColor"
                />
                <span>Chất lượng</span>
              </div>
            </div>

            <ul class="menu">
              <li
                v-for="(item, index) in settings.quality.all"
                :key="index"
                :class="{ active: settings.quality.current == item }"
                @click="settings.quality.current = item"
              >
                <!-- <Icon
                  v-if="settings.quality.current == item"
                  name="ic:baseline-check"
                /> -->

                <CheckIcon
                  v-if="settings.quality.current == item"
                  width="1.8rem"
                  height="1.8rem"
                  fill="currentColor"
                />
                <span> {{ item }}</span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import ReplayIcon from '~/assets/svgs/icons/replay.svg?component';
import PlayIcon from '~/assets/svgs/icons/play.svg?component';
import PauseIcon from '~/assets/svgs/icons/pause.svg?component';
import RewindIcon from '~/assets/svgs/icons/rewind.svg?component';
import VolumeUp from '~/assets/svgs/icons/volume-up.svg?component';
import VolumeDown from '~/assets/svgs/icons/volume-down.svg?component';
import VolumeOff from '~/assets/svgs/icons/volume-off.svg?component';
import FastRewind from '~/assets/svgs/icons/fast-rewind.svg?component';
import FastForward from '~/assets/svgs/icons/fast-forward.svg?component';
import SettingIcon from '~/assets/svgs/icons/setting.svg?component';
import PictureInPicture from '~/assets/svgs/icons/picture-in-picture.svg?component';
import FullscreenIcon from '~/assets/svgs/icons/fullscreen.svg?component';
import FullscreenExitIcon from '~/assets/svgs/icons/fullscreen-exit.svg?component';
import LightMode from '~/assets/svgs/icons/light-mode.svg?component';
import ArrowForwardIos from '~/assets/svgs/icons/arrow-forward-ios.svg?component';
import HighQuality from '~/assets/svgs/icons/high-quality.svg?component';
import ArrowBackIos from '~/assets/svgs/icons/arrow-back-ios.svg?component';
import CheckIcon from '~/assets/svgs/icons/check.svg?component';

// import { CloseBtn } from '~/components/Button';
// import { LoadingSpinner } from '~/components/Loading';
// import CloseBtn from '~/components/Button/CloseBtn/CloseBtn.vue';
// import LoadingSpinner from '~/components/Loading/LoadingSpinner/LoadingSpinner.vue';
// import { getImage } from '~/services/image';
import { getVideo } from '~/services/video';
import { useLocalStorage } from '@vueuse/core';
import Hls from 'hls.js';

const props = withDefaults(
  defineProps<{
    dataMovie: any;
    episode?: any;
    loadingData: boolean;
    backdrop: string;
    videoUrl: string;
  }>(),
  {
    loadingData: true
  }
);

const emits = defineEmits<{
  onPlay: [e: any];
  onTimeUpdate: [e: any];
}>();

const nuxtConfig = useRuntimeConfig();
const authStore = useAuthStore();
const route = useRoute();
const movieVipNumber = computed<number>(
  () => props.dataMovie?.vip || props?.episode?.vip || 0
);
const isEligibleToWatch = computed<boolean>(
  () =>
    (!props.loadingData && movieVipNumber.value == 0) ||
    authStore.vipNumber! >= movieVipNumber.value
);
const ísWatchable = computed<boolean>(
  () =>
    !(
      (videoStates.isLoading &&
        !videoStates.isEndedVideo &&
        !videoStates.isRewind.enable) ||
      !mounted.value ||
      props.loadingData
    )
);
const videoSrc = computed<string>(() =>
  getVideo(
    props.videoUrl.endsWith('.m3u8') ? props.videoUrl : props.videoUrl + '.m3u8'
  )
);
const videoPlayerStorageStates = useLocalStorage(
  STORAGE.VIDEO_PLAYER_STATES.KEY,
  {
    [STORAGE.VIDEO_PLAYER_STATES.VOLUME]: 100,
    [STORAGE.VIDEO_PLAYER_STATES.MUTED]: false
  }
);
const blobVideoSrc = ref<string>('');
const videoPlayer = ref<HTMLElement>();
const video = ref<HTMLVideoElement>();
const overlayProgress = ref<HTMLElement>();
const progressBar = ref<HTMLElement>();
const timeline = ref<HTMLElement>();
const canvasPreviewImg = ref();
const isInHistory = defineModel<boolean>('isInHistory', { default: false });
const historyProgress = defineModel<{
  duration: number;
  percent: number;
  seconds: number;
}>('historyProgress', {
  default: {
    duration: 0,
    percent: 0,
    seconds: 0
  }
});
const videoStates = reactive({
  isLoading: false,
  isLoaded: false,
  isPlayVideo: true,
  isScrubbingProgressBar: false,
  isFullScreen: false,
  isChangingVolume: false,
  isVolumeOff:
    videoPlayerStorageStates.value[STORAGE.VIDEO_PLAYER_STATES.MUTED] || false,
  isEndedVideo: false,
  isMouseMoveOverlayProgress: false,
  isHideControls: false,
  isShowControls: false,
  isShowNotify: isInHistory.value || false,
  isActiveControlsAnimation: false,
  isRewind: {
    enable: false,
    replay: false,
    forward: false
  }
});
const settingStates = reactive({
  enable: false,
  switchBackgroud: true,
  subSetting: {
    enable: false,
    playback: false,
    quality: false
  }
});
const settings = reactive({
  playback: {
    all: ['0.25', '0.5', '0.75', 'Bình thường', '1.25', '1.5', '1.75', '2'],
    current: 'Bình thường'
  },
  quality: {
    all: [
      '2560p - 4K',
      '1440p - 2K',
      '1080p - HD',
      '720p',
      '480p',
      '360p',
      'Tự động'
    ],
    current: '1080p - HD'
  }
});
const volume = ref<number>(
  (videoPlayerStorageStates.value[
    STORAGE.VIDEO_PLAYER_STATES.VOLUME
  ] as number) || 100
);
const timeUpdate = ref<string>('0:00');
const timelineUpdate = ref<string>('0:00');
const duration = ref<string>('00:00');
const timeOutShowControls = ref<any>();
const timeOutVolumeChange = ref<any>();
const mounted = ref<boolean>(false);
const hls = ref<Hls | null>();

const loadM3u8Video = async () => {
  // if (Hls.isSupported()) {
  //   const hls = new Hls();
  //   console.log(videoSrc.value);
  //   hls.on(Hls.Events.ERROR, (event, data) => {
  //     console.error(`hls.js error: ${data.type} - ${data.details}`);
  //   });
  //   hls.loadSource(
  //     'http://localhost:5002/static/videos/feature/Transformer_5/Transformer_5.m3u8'
  //   );
  //   hls.attachMedia(video.value!);
  //   console.log('HLS.js is supported');
  // } else {
  //   console.error('HLS is not supported on your browser, but native HLS is');
  // }

  var videoElment = document.getElementById('video-player') as HTMLVideoElement;

  if (!videoElment) return;

  // video.value!.autoplay = true;
  video.value!.muted = true;

  if (Hls.isSupported()) {
    hls.value = new Hls();
    hls.value.loadSource(videoSrc.value);
    hls.value.attachMedia(videoElment!);
    hls.value.on(Hls.Events.MANIFEST_PARSED, async function () {
      await videoElment?.play().catch(() => {
        if (videoStates.isPlayVideo) {
          videoStates.isPlayVideo = false;
        }
      });
    });
  } else if (videoElment?.canPlayType('application/vnd.apple.mpegurl')) {
    videoElment!.src = videoSrc.value;
    videoElment?.addEventListener('loadedmetadata', async function () {
      await videoElment?.play().catch(() => {
        if (videoStates.isPlayVideo) {
          videoStates.isPlayVideo = false;
        }
      });
    });
  }
};

watch(
  () => props.episode,
  async (newVal, oldVal) => {
    if (!isEligibleToWatch.value) return;

    await nextTick();

    if (props.dataMovie?.media_type == 'tv' && newVal && video.value) {
      loadM3u8Video();

      // video.value!.pause();
      // video.value!.src = videoSrc.value;
      // video.value!.load();

      if (videoStates.isPlayVideo == false) {
        videoStates.isPlayVideo = true;
      }
    }
  }
  // { immediate: true }
);

watch(
  isInHistory,
  () => {
    if (isInHistory.value) {
      videoStates.isShowNotify = true;
    }
  },
  { immediate: true }
);

const windowPointerUp = () => {
  if (videoStates.isScrubbingProgressBar) {
    if (videoStates.isPlayVideo) {
      video.value!.play();
    }
  }

  videoStates.isScrubbingProgressBar = false;
};

const windowTouchEnd = () => {
  videoStates.isScrubbingProgressBar = false;
  videoStates.isShowControls = false;
  videoStates.isMouseMoveOverlayProgress = false;

  if (videoStates.isLoaded) {
    if (videoStates.isEndedVideo || videoStates.isLoading) {
      return;
    }

    if (videoStates.isPlayVideo) {
      video.value!.play();
    }
  }
};

const clearVideoPlayer = () => {
  if (!isEligibleToWatch.value && !video.value) return;

  if (!video.value!.paused) {
    video.value!.pause();
  }

  if (hls.value) {
    hls.value.destroy();
    hls.value = null;
  }

  window.removeEventListener('pointerup', windowPointerUp);
  window.removeEventListener('touchend', windowTouchEnd);
  video.value!.removeEventListener('progress', onProgressVideo);
};

onBeforeUnmount(() => {
  clearVideoPlayer();
});

onBeforeRouteLeave(() => {
  clearVideoPlayer();
});

onBeforeMount(() => {});

onMounted(async () => {
  await loadM3u8Video();

  mounted.value = true;

  if (!isEligibleToWatch.value) return;

  if (video.value!.autoplay) {
    video.value!.autoplay = false;
  }

  if (videoStates.isVolumeOff == true) {
    video.value!.muted = true;
  }

  if (video.value!.paused == true) {
    const event = new Event('canplay');
    video.value!.dispatchEvent(event);
  }

  if (videoStates.isPlayVideo == false) {
    videoStates.isPlayVideo = true;
  }

  videoPlayer.value?.scrollIntoView({
    block: 'end',
    behavior: 'instant'
  });

  duration.value = formatDuration(video.value!.duration)!;

  window.addEventListener('pointerup', windowPointerUp);

  window.addEventListener('touchend', windowTouchEnd);

  window.addEventListener('pointermove', (e) => {
    if (videoStates.isScrubbingProgressBar) {
      handleTimeUpdate(e);
    }
  });

  window.addEventListener('touchmove', (e) => {
    if (videoStates.isScrubbingProgressBar) {
      videoStates.isShowControls = true;
      [...e.changedTouches].forEach((touch) => {
        handleTimeUpdate({ x: touch.pageX });
      });
    }
  });

  window.addEventListener('click', (e: any) => {
    if (settingStates.enable) {
      if (
        !e.target.closest('.video-player .settings') &&
        !e.target.closest(
          '.video-player .controls .main-controls .right svg.setting'
        )
      ) {
        settingStates.enable = false;
        onCloseSettings();
      }
    }
  });
});

const handleTimeUpdate = (e: any) => {
  if (videoStates.isPlayVideo) {
    video.value!.pause();
  }

  const rect = overlayProgress.value!.getBoundingClientRect();

  const percent =
    Math.min(Math.max(0, e.x - rect.left), rect.width) / rect.width;

  progressBar.value!.style.setProperty('--progress-width', percent.toString());

  video.value!.currentTime = percent * video.value!.duration;

  videoStates.isEndedVideo = video.value!.currentTime == video.value!.duration;

  drawTimeLine(e);
};

const formatDuration = (time: number): string => {
  if (isNaN(time)) {
    return '00:00';
  }

  // const hours: number | string = Math.floor(time / 3600);
  // let mins: number | string = Math.floor(time / 60);
  // let seconds: number | string = Math.floor(time % 60);

  // if (hours == 0) {
  //   seconds = seconds < 10 ? (seconds = '0' + seconds) : seconds;
  //   return `${mins}:${seconds}`;
  // } else {
  //   mins = mins < 10 ? (mins = '0' + mins) : mins;
  //   seconds = seconds < 10 ? (seconds = '0' + seconds) : seconds;
  //   return `${hours}:${mins}:${seconds}`;
  // }

  const hours: number | string = Math.floor(time / 3600); // Số giờ
  const mins: number | string = Math.floor((time % 3600) / 60); // Số phút còn lại sau khi tính số giờ
  let seconds: number | string = Math.floor(time % 60); // Số giây

  // Thêm số '0' trước giây và phút nếu nhỏ hơn 10
  seconds = seconds < 10 ? '0' + seconds : seconds;
  const formattedMins = mins < 10 ? '0' + mins : mins;

  // Nếu video có hơn 1 giờ
  if (hours > 0) {
    return `${hours}:${formattedMins}:${seconds}`;
  } else {
    return `${formattedMins}:${seconds}`; // Trường hợp chỉ có phút và giây
  }
};

const onLoadStartVideo = () => {
  // console.log('load start video');
  videoStates.isLoading = true;

  // video.value.currentTime = 0;
  // progressBar.value!.style.setProperty('--progress-width', 0);
  // overlayProgress.value!.style.setProperty('--seekable-width', 0);
};

const onCanPlayVideo = () => {
  if (videoStates.isLoading) {
    videoStates.isLoading = false;
  }

  if (!video.value || video.value!.ended) return;

  video.value!.play().catch(() => {
    if (videoStates.isPlayVideo) {
      videoStates.isPlayVideo = false;
    }
  });
};

const onLoadedDataVideo = () => {
  if (!video.value) return;

  // console.log('loaded start video');
  if (video.value!.muted) {
    video.value!.muted = false;
  }

  videoStates.isLoaded = true;
  duration.value = formatDuration(video.value!.duration)!;
};

const onTimeUpdateVideo = (e: any) => {
  timeUpdate.value = formatDuration(e.target.currentTime)!;
  const percent = e.target.currentTime / e.target.duration;
  progressBar.value!?.style.setProperty('--progress-width', percent.toString());

  if (!video.value) return;

  emits('onTimeUpdate', {
    seconds: video.value!.currentTime,
    percent: video.value!.currentTime / video.value!.duration,
    duration: video.value!.duration
  });
};

const onProgressVideo = (e: any) => {
  // console.log('buffered:', video.value.buffered.end(0));
  // console.log('seekable:', video.value.seekable.end(0));

  if (videoStates.isLoaded && video.value) {
    const bufferedLength: number = video.value!.buffered.length;

    for (let i = 0; i < bufferedLength; i++) {
      const bufferedStart = video.value!.buffered.start(bufferedLength - 1 - i);
      const bufferedEnd = video.value!.buffered.end(bufferedLength - 1 - i);

      // console.log(`buffered start ${bufferedLength - 1 - i}:`, bufferedStart);
      // console.log(`buffered end ${bufferedLength - 1 - i}:`, bufferedEnd);

      if (video.value!.currentTime > bufferedStart) {
        const percent = bufferedEnd / e.target.duration;
        overlayProgress.value!.style.setProperty(
          '--seekable-width',
          percent.toString()
        );
        break;
      }
    }
  }
};

const onMouseMoveVideo = () => {
  if (videoStates.isPlayVideo && !videoStates.isEndedVideo) {
    videoStates.isHideControls = false;
    clearTimeout(timeOutShowControls.value);

    timeOutShowControls.value = setTimeout(() => {
      videoStates.isHideControls = true;
    }, 5000);
  }
};

const onMouseLeaveVideo = () => {
  if (videoStates.isLoaded) {
    clearTimeout(timeOutShowControls.value);
    videoStates.isHideControls = false;
    videoStates.isShowControls = false;
  }
};

const onWaitingVideo = (e: any) => {
  videoStates.isLoading = true;
};

const onPLayingVideo = (e: any) => {
  videoStates.isLoading = false;
  videoStates.isPlayVideo = true;
};

const onPlayVideo = (e: any) => {
  emits('onPlay', {
    seconds: e!.target!.currentTime,
    percent: e!.target!.currentTime / e!.target!.duration,
    duration: e!.target!.duration
  });
};

const onPauseVideo = () => {
  // videoStates.isPlayVideo = false;
};

const checkEndedVideo = () => {
  if (video.value!.ended) {
    videoStates.isEndedVideo = true;
  } else {
    videoStates.isEndedVideo = false;
  }
};

const onEndedVideo = () => {
  videoStates.isEndedVideo = true;
  videoStates.isShowControls = true;
};

const onClickPlay = () => {
  videoStates.isPlayVideo = true;
  video.value!.play();
};

const onClickPause = () => {
  videoStates.isPlayVideo = false;
  video.value!.pause();
};

const onClickReplayVideo = () => {
  video.value!.currentTime = 0;
  progressBar.value!.style.setProperty('--progress-width', '0');
  videoStates.isPlayVideo = true;
  videoStates.isEndedVideo = false;
  videoStates.isShowControls = false;
  video.value!.play();
};

const playVideo = async () => {
  video.value!.play();
  videoStates.isPlayVideo = true;

  videoStates.isActiveControlsAnimation = false;
  await wait(10);
  videoStates.isActiveControlsAnimation = true;

  videoStates.isRewind.enable = false;
};

const pauseVideo = async () => {
  video.value!.pause();
  videoStates.isPlayVideo = false;

  videoStates.isActiveControlsAnimation = false;
  await wait(10);
  videoStates.isActiveControlsAnimation = true;

  videoStates.isRewind.enable = false;
};

const onClickVideo = (e: any) => {
  if (video.value!.ended || videoStates.isEndedVideo || videoStates.isLoading) {
    return;
  }

  if (videoStates.isPlayVideo) {
    pauseVideo();
    // hide controls
    clearTimeout(timeOutShowControls.value);
    videoStates.isHideControls = false;
  } else {
    playVideo();
    // hide controls
    videoStates.isHideControls = false;
    clearTimeout(timeOutShowControls.value);

    timeOutShowControls.value = setTimeout(() => {
      videoStates.isHideControls = true;
    }, 5000);
  }
};

const rewindVideo = async (value: number) => {
  if (video.value!.currentTime != 0) {
    video.value!.currentTime -= value;
    checkEndedVideo();

    const percent = video.value!.currentTime / video.value!.duration;
    progressBar.value!.style.setProperty(
      '--progress-width',
      percent.toString()
    );

    if (videoStates.isPlayVideo) {
      video.value!.play();
    }

    videoStates.isActiveControlsAnimation = false;
    await wait(10);
    videoStates.isActiveControlsAnimation = true;

    videoStates.isRewind.enable = true;
    videoStates.isRewind.replay = true;
    videoStates.isRewind.forward = false;
  }
};

const onClickRewind = () => {
  rewindVideo(10);
};

const forwardVideo = async (value: number) => {
  if (!videoStates.isEndedVideo) {
    video.value!.currentTime += value;
    checkEndedVideo();

    const percent = video.value!.currentTime / video.value!.duration;
    progressBar.value!.style.setProperty(
      '--progress-width',
      percent.toString()
    );

    videoStates.isActiveControlsAnimation = false;
    await wait(10);
    videoStates.isActiveControlsAnimation = true;

    videoStates.isRewind.enable = true;
    videoStates.isRewind.replay = false;
    videoStates.isRewind.forward = true;
  }
};

const onClickForward = () => {
  forwardVideo(10);
};

const onTouchStartProgressBar = (e: any) => {
  videoStates.isScrubbingProgressBar = true;
  [...e.changedTouches].forEach((touch) => {
    handleTimeUpdate({ x: touch.pageX });
  });
};

const onMouseDownProgressBar = (e: any) => {
  videoStates.isScrubbingProgressBar = true;

  handleTimeUpdate(e);
};

const onTouchEndProgressBar = (e: any) => {
  videoStates.isScrubbingProgressBar = false;
  videoStates.isShowControls = false;
  videoStates.isMouseMoveOverlayProgress = false;

  if (videoStates.isPlayVideo) {
    video.value!.play();
  }
};

const onMouseUpProgressBar = () => {
  videoStates.isScrubbingProgressBar = false;

  if (videoStates.isPlayVideo) {
    video.value!.play();
  }
};

const onTouchMoveProgressBar = (e: any) => {
  videoStates.isMouseMoveOverlayProgress = true;
  videoStates.isShowControls = true;
  const rect = overlayProgress.value!.getBoundingClientRect();

  [...e.changedTouches].forEach((touch) => {
    const percent =
      Math.min(Math.max(0, touch.pageX - rect.left), rect.width) / rect.width;
    overlayProgress.value!.style.setProperty(
      '--preview-width',
      percent.toString()
    );

    if (videoStates.isScrubbingProgressBar) {
      handleTimeUpdate({ x: touch.pageX });
    } else {
      drawTimeLine({ x: touch.pageX });
    }
  });
};

const onMouseMoveProgressBar = (e: any) => {
  videoStates.isMouseMoveOverlayProgress = true;
  const rect = overlayProgress.value!.getBoundingClientRect();

  const percent =
    Math.min(Math.max(0, e.x - rect.left), rect.width) / rect.width;

  overlayProgress.value!.style.setProperty(
    '--preview-width',
    percent.toString()
  );

  if (videoStates.isScrubbingProgressBar) {
    handleTimeUpdate(e);
  } else {
    drawTimeLine(e);
  }
};

const onMouseLeaveProgressBar = (e: any) => {
  videoStates.isMouseMoveOverlayProgress = false;
};

const drawTimeLine = (e: any) => {
  const rect = overlayProgress.value!.getBoundingClientRect();

  const percent =
    Math.min(Math.max(0, e.x - rect.left), rect.width) / rect.width;

  timelineUpdate.value = formatDuration(percent * video.value!.duration)!;

  const timeLinePosition = Math.max(0, e.x - rect.left);

  const timeLinePositionFinnal = Math.min(
    // Math.max(10, timeLinePosition - timeline.value!.offsetWidth / 2 + 10),
    Math.max(0, timeLinePosition - timeline.value!.offsetWidth / 2),
    overlayProgress.value!.offsetWidth - timeline.value!.offsetWidth
  );

  timeline.value!.style.setProperty(
    '--timeline-position',
    timeLinePositionFinnal + 'px'
  );

  // videoTemp.value.currentTime = percent * videoTemp.value.duration;

  // const ctx = canvasPreviewImg.value.getContext('2d');

  // ctx.drawImage(video.value!, 0, 0, 160, 90);

  // canvasPreviewImg.value.toBlob((blob: any) => {
  //   const previewImg = timeline.value!.querySelector(
  //     '.preview-img'
  //   ) as HTMLImageElement;
  //   previewImg.src = URL.createObjectURL(blob);
  // });

  // const img_url = canvasPreviewImg.value.toDataURL('image/jpeg');

  // const previewImg = timeline.value!.querySelector(
  //   '.preview-img'
  // ) as HTMLImageElement;
  // previewImg.src = img_url;
};

const onClickFullScreen = () => {
  videoStates.isFullScreen = true;
  videoPlayer.value!.requestFullscreen();
};

const onClickFullScreenExit = () => {
  videoStates.isFullScreen = false;
  document.exitFullscreen();
};

const onClickVolumeUp = () => {
  video.value!.muted = true;
  videoStates.isVolumeOff = true;

  videoPlayerStorageStates.value[STORAGE.VIDEO_PLAYER_STATES.MUTED] = true;
};

const onClickVolumeOff = () => {
  video.value!.muted = false;
  videoStates.isVolumeOff = false;

  videoPlayerStorageStates.value[STORAGE.VIDEO_PLAYER_STATES.MUTED] = false;
};

const onChangeVolume = (value: number) => {
  videoStates.isShowControls = true;
  videoStates.isChangingVolume = true;

  volume.value = value;
  video.value!.volume = value / 100;
  videoPlayerStorageStates.value[STORAGE.VIDEO_PLAYER_STATES.VOLUME] = value;

  if (volume.value > 0 && video.value!.muted) {
    video.value!.muted = false;
  }

  clearTimeout(timeOutVolumeChange.value);

  timeOutVolumeChange.value = setTimeout(() => {
    videoStates.isChangingVolume = false;
  }, 5000);
};

watch(volume, (newVal, oldVal) => {
  videoStates.isVolumeOff = video.value!.volume == 0;
});

const onClickPictureInPicture = () => {
  video.value!.requestPictureInPicture();
};

const onClickItemPlayback = (item: string) => {
  settings.playback.current = item;

  if (item == 'Bình thường') {
    video.value!.playbackRate = 1;
  } else {
    video.value!.playbackRate = +item;
  }
};

const onCloseSettings = async () => {
  await wait(150);

  settingStates.subSetting.enable = false;
  settingStates.subSetting.playback = false;
  settingStates.subSetting.quality = false;
};

const onClickPlayAgain = () => {
  video.value!.currentTime = 0;
  progressBar.value!.style.setProperty('--progress-width', '0');
  videoStates.isShowNotify = false;
  video.value!.play();
  videoStates.isPlayVideo = true;
};

const onClickKeepWatching = () => {
  video.value!.currentTime = historyProgress.value.seconds;
  progressBar.value!.style.setProperty(
    '--progress-width',
    historyProgress.value.percent.toString()
  );
  videoStates.isShowNotify = false;
  video.value!.play();
  videoStates.isPlayVideo = true;
};

const onKeyDownVideo = (e: any) => {
  // show controls
  if ([32, 37, 39].includes(e.keyCode)) {
    videoStates.isShowControls = true;
    clearTimeout(timeOutShowControls.value);

    timeOutShowControls.value = setTimeout(() => {
      videoStates.isShowControls = false;
    }, 5000);
  }

  switch (e.keyCode) {
    case 32:
      e.preventDefault();

      if (videoStates.isPlayVideo) {
        pauseVideo();
      } else {
        playVideo();
      }
      break;
    case 37:
      rewindVideo(10);
      break;
    case 39:
      forwardVideo(10);
      break;
    case 77:
      if (videoStates.isVolumeOff) {
        video.value!.muted = false;
        videoStates.isVolumeOff = false;
      } else {
        video.value!.muted = true;
        videoStates.isVolumeOff = true;
      }
      break;
    case 70:
      if (videoStates.isFullScreen) {
        videoStates.isFullScreen = false;
        document.exitFullscreen();
      } else {
        videoStates.isFullScreen = true;
        window.screen.orientation
          .lock('landscape')
          .then(function () {})
          .catch(function () {});
        videoPlayer.value!.requestFullscreen();
      }
      break;
    default:
      break;
  }
};

const handleClickVideoPlayer = () => {
  videoPlayer.value!.scrollIntoView({ block: 'end' });
};
</script>

<style lang="scss" src="./VideoPlayer.scss" scoped></style>
<!-- <style lang="scss">
@import url('./VideoPlayer.scss');
</style> -->
